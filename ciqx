#!/usr/bin/env bash
#
# ciqx - Terminal-based IDE for Garmin Connect IQ Development
# Orchestrates monkeyc, monkeydo, git, gh, and other CLI tools
# Built with SOLID principles and modular plugin architecture
#

set -euo pipefail

# Core Configuration
CIQX_VERSION="1.0.0"
CIQX_HOME="${CIQX_HOME:-$HOME/.ciqx}"
CIQX_CONFIG="${CIQX_CONFIG:-./ciqx.yml}"
CIQX_LOG_LEVEL="${CIQX_LOG_LEVEL:-INFO}"

# Ensure ciqx home exists
mkdir -p "$CIQX_HOME/plugins" "$CIQX_HOME/cache" "$CIQX_HOME/logs"

# Logging (Single Responsibility)
log() {
    local level="$1"
    shift
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] [$level] $*" | tee -a "$CIQX_HOME/logs/ciqx.log"
}

log_info() { log "INFO" "$@"; }
log_warn() { log "WARN" "$@"; }
log_error() { log "ERROR" "$@"; }
log_debug() { [[ "$CIQX_LOG_LEVEL" == "DEBUG" ]] && log "DEBUG" "$@" || true; }

# Service Registry (Dependency Inversion)
declare -A services
declare -A plugins

register_service() {
    local token="$1"
    local implementation="$2"
    services["$token"]="$implementation"
    log_debug "Registered service: $token -> $implementation"
}

resolve_service() {
    local token="$1"
    echo "${services[$token]:-}"
}

# Plugin System (Open/Closed Principle)
load_plugin() {
    local plugin_file="$1"
    if [[ -f "$plugin_file" ]]; then
        log_debug "Loading plugin: $plugin_file"
        source "$plugin_file"
        plugins["$(basename "$plugin_file")"]="loaded"
    fi
}

load_plugins() {
    # Load core plugins
    for plugin in "$CIQX_HOME/plugins"/*.sh; do
        [[ -f "$plugin" ]] && load_plugin "$plugin"
    done
    
    # Load local project plugins
    for plugin in ./plugins/*.sh; do
        [[ -f "$plugin" ]] && load_plugin "$plugin"
    done
}

# Configuration Service (Interface Segregation)
load_config() {
    if [[ -f "$CIQX_CONFIG" ]]; then
        log_debug "Loading config: $CIQX_CONFIG"
        # Parse YAML-like config (simplified for bash)
        eval "$(grep -E '^[a-zA-Z_][a-zA-Z0-9_]*:' "$CIQX_CONFIG" | sed 's/: */=/' | sed 's/^/CIQX_/')"
    else
        log_warn "No config file found at $CIQX_CONFIG"
    fi
}

# Command Router (Single Responsibility)
show_help() {
    cat << 'EOF'
ciqx - Terminal IDE for Garmin Connect IQ Development

USAGE:
    ciqx <command> [options]

COMMANDS:
    init <type>          - Initialize new project (watchface, datafield, widget, app)
    doctor               - Verify SDK, tools, and environment
    devices              - List available device targets
    build [options]      - Build project for target devices
    run [options]        - Build and run in simulator
    watch [options]      - Build and run with file watching
    test                 - Run tests
    release [version]    - Create release with git tag and GitHub release
    clean                - Clean build artifacts

BUILD OPTIONS:
    -t, --target <device>    Target device (default: fenix7)
    -p, --profile <profile>  Build profile (debug, release)
    -a, --all               Build for all configured devices
    -w, --watch             Watch for file changes

EXAMPLES:
    ciqx init watchface
    ciqx build -t fenix7 -p debug
    ciqx run -t venu2 --watch
    ciqx release minor

For more information: ciqx help <command>
EOF
}

# Core Commands (following Command Pattern)
cmd_init() {
    local app_type="${1:-watchface}"
    log_info "Initializing $app_type project..."
    
    # Call scaffolding service
    local scaffolder=$(resolve_service "scaffolder")
    if [[ -n "$scaffolder" ]]; then
        $scaffolder "$app_type"
    else
        # Fallback implementation
        mkdir -p source resources
        cat > manifest.xml << 'EOF'
<iq:manifest xmlns:iq="http://www.garmin.com/xml/connectiq" version="3">
    <iq:application entry="App" id="00000000-0000-0000-0000-000000000000" launcherIcon="@Drawables.LauncherIcon" name="@Strings.AppName" type="watchface" version="0.0.1">
        <iq:products>
            <iq:product id="fenix7"/>
        </iq:products>
        <iq:permissions/>
        <iq:languages>
            <iq:language>eng</iq:language>
        </iq:languages>
    </iq:application>
</iq:manifest>
EOF
        
        cat > ciqx.yml << 'EOF'
sdk:
  path: ~/.Garmin/ConnectIQ/SDK
project:
  manifest: ./manifest.xml
  src: [source]
  resources: [resources]
  outDir: ./build
devices:
  default: fenix7
  targets: [fenix7, venu2, vivoactive4]
profiles:
  debug:
    optimize: false
    defines: [DEBUG]
  release:
    optimize: true
signing:
  developerKey: ./developer_key.der
EOF
        log_info "Project initialized successfully!"
    fi
}

cmd_doctor() {
    log_info "Running environment diagnostics..."
    
    # Check SDK
    local sdk_path="${CIQX_sdk_path:-$HOME/.Garmin/ConnectIQ/SDK}"
    if [[ -d "$sdk_path" ]]; then
        log_info "✓ Connect IQ SDK found at: $sdk_path"
    else
        log_error "✗ Connect IQ SDK not found. Please install from developer.garmin.com"
        return 1
    fi
    
    # Check monkeyc
    local monkeyc_path="$sdk_path/bin/monkeyc"
    if [[ -x "$monkeyc_path" ]]; then
        log_info "✓ monkeyc compiler found"
        log_debug "$($monkeyc_path --version 2>&1 | head -1)"
    else
        log_error "✗ monkeyc not found or not executable"
        return 1
    fi
    
    # Check monkeydo
    local monkeydo_path="$sdk_path/bin/monkeydo"
    if [[ -x "$monkeydo_path" ]]; then
        log_info "✓ monkeydo simulator found"
    else
        log_error "✗ monkeydo not found"
        return 1
    fi
    
    # Check developer key
    local dev_key="${CIQX_signing_developerKey:-./developer_key.der}"
    if [[ -f "$dev_key" ]]; then
        log_info "✓ Developer key found"
    else
        log_warn "⚠ Developer key not found at $dev_key"
        log_info "Generate with: openssl genrsa -out developer_key.pem 4096 && openssl pkcs8 -topk8 -inform PEM -outform DER -in developer_key.pem -out developer_key.der -nocrypt"
    fi
    
    # Check git
    if command -v git >/dev/null 2>&1; then
        log_info "✓ Git found"
    else
        log_warn "⚠ Git not found - version control features disabled"
    fi
    
    # Check gh
    if command -v gh >/dev/null 2>&1; then
        log_info "✓ GitHub CLI found"
    else
        log_warn "⚠ GitHub CLI not found - release features disabled"
    fi
    
    log_info "Environment check complete!"
}

cmd_devices() {
    log_info "Available device targets:"
    cat << 'EOF'
    fenix7          - Garmin fēnix 7 (260x260)
    fenix7s         - Garmin fēnix 7S (240x240)
    fenix7x         - Garmin fēnix 7X (280x280)
    venu2           - Garmin Venu 2 (416x416)
    venu2s          - Garmin Venu 2S (360x360)
    vivoactive4     - Garmin Vívoactive 4 (260x260)
    vivoactive4s    - Garmin Vívoactive 4S (218x218)
    epix2           - Garmin Epix (Gen 2) (416x416)
EOF
}

cmd_build() {
    local target="${CIQX_devices_default:-fenix7}"
    local profile="debug"
    local build_all=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case $1 in
            -t|--target)
                target="$2"
                shift 2
                ;;
            -p|--profile)
                profile="$2"
                shift 2
                ;;
            -a|--all)
                build_all=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    local compiler=$(resolve_service "compiler")
    if [[ -n "$compiler" ]]; then
        $compiler "$target" "$profile" "$build_all"
    else
        # Fallback implementation
        build_fallback "$target" "$profile" "$build_all"
    fi
}

build_fallback() {
    local target="$1"
    local profile="$2"
    local build_all="$3"
    
    local sdk_path="${CIQX_sdk_path:-$HOME/.Garmin/ConnectIQ/SDK}"
    local monkeyc="$sdk_path/bin/monkeyc"
    local manifest="${CIQX_project_manifest:-./manifest.xml}"
    local out_dir="${CIQX_project_outDir:-./build}"
    local dev_key="${CIQX_signing_developerKey:-./developer_key.der}"
    
    mkdir -p "$out_dir"
    
    if [[ "$build_all" == "true" ]]; then
        local devices=(${CIQX_devices_targets:-fenix7 venu2})
        for device in "${devices[@]}"; do
            log_info "Building for $device ($profile)..."
            build_device "$monkeyc" "$manifest" "$out_dir" "$device" "$profile" "$dev_key"
        done
    else
        log_info "Building for $target ($profile)..."
        build_device "$monkeyc" "$manifest" "$out_dir" "$target" "$profile" "$dev_key"
    fi
}

build_device() {
    local monkeyc="$1"
    local manifest="$2"
    local out_dir="$3"
    local device="$4"
    local profile="$5"
    local dev_key="$6"
    
    local output="$out_dir/${device}.prg"
    local flags=""
    
    if [[ "$profile" == "debug" ]]; then
        flags="-g"
    elif [[ "$profile" == "release" ]]; then
        flags="-r"
    fi
    
    if ! "$monkeyc" -f "$manifest" -o "$output" -d "$device" -y "$dev_key" $flags; then
        log_error "Build failed for $device"
        return 1
    fi
    
    log_info "✓ Built: $output"
}

cmd_run() {
    local target="${CIQX_devices_default:-fenix7}"
    local profile="debug"
    local watch_mode=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case $1 in
            -t|--target)
                target="$2"
                shift 2
                ;;
            -p|--profile)
                profile="$2"
                shift 2
                ;;
            -w|--watch)
                watch_mode=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Build first
    cmd_build -t "$target" -p "$profile"
    
    # Run in simulator
    local sdk_path="${CIQX_sdk_path:-$HOME/.Garmin/ConnectIQ/SDK}"
    local monkeydo="$sdk_path/bin/monkeydo"
    local out_dir="${CIQX_project_outDir:-./build}"
    local app="$out_dir/${target}.prg"
    
    if [[ ! -f "$app" ]]; then
        log_error "App not found: $app"
        return 1
    fi
    
    log_info "Running $app on $target..."
    
    if [[ "$watch_mode" == "true" ]]; then
        cmd_watch -t "$target" -p "$profile"
    else
        "$monkeydo" "$app" "$target"
    fi
}

cmd_watch() {
    local target="${CIQX_devices_default:-fenix7}"
    local profile="debug"
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case $1 in
            -t|--target)
                target="$2"
                shift 2
                ;;
            -p|--profile)
                profile="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done
    
    log_info "Starting watch mode for $target ($profile)..."
    log_info "Press Ctrl+C to stop"
    
    # Initial build and run
    cmd_run -t "$target" -p "$profile" &
    local app_pid=$!
    
    # Simple file watching (requires fswatch if available)
    if command -v fswatch >/dev/null 2>&1; then
        fswatch -o source/ resources/ manifest.xml | while read -r _; do
            log_info "Files changed, rebuilding..."
            kill $app_pid 2>/dev/null || true
            wait $app_pid 2>/dev/null || true
            cmd_run -t "$target" -p "$profile" &
            app_pid=$!
        done
    else
        log_warn "fswatch not available, falling back to polling"
        local last_mod=$(find source resources manifest.xml -type f -exec stat -f %m {} \; 2>/dev/null | sort -nr | head -1)
        
        while true; do
            sleep 2
            local current_mod=$(find source resources manifest.xml -type f -exec stat -f %m {} \; 2>/dev/null | sort -nr | head -1)
            if [[ "$current_mod" != "$last_mod" ]]; then
                log_info "Files changed, rebuilding..."
                kill $app_pid 2>/dev/null || true
                wait $app_pid 2>/dev/null || true
                cmd_run -t "$target" -p "$profile" &
                app_pid=$!
                last_mod="$current_mod"
            fi
        done
    fi
}

cmd_test() {
    log_info "Running tests..."
    # Test implementation would go here
    log_warn "Test functionality not yet implemented"
}

cmd_release() {
    local version_bump="${1:-patch}"
    
    log_info "Creating release with $version_bump version bump..."
    
    # Verify clean git state
    if ! git diff-index --quiet HEAD --; then
        log_error "Working directory is dirty. Commit or stash changes first."
        return 1
    fi
    
    # Build all targets for release
    cmd_build -p release -a
    
    # Version bump (simplified)
    local current_version=$(grep -o 'version="[^"]*"' manifest.xml | cut -d'"' -f2)
    log_info "Current version: $current_version"
    
    # Create git tag
    local new_version="v$(date +%Y.%m.%d)"
    git tag "$new_version"
    git push origin "$new_version"
    
    # Create GitHub release if gh is available
    if command -v gh >/dev/null 2>&1; then
        local assets=""
        for prg in build/*.prg; do
            [[ -f "$prg" ]] && assets="$assets $prg"
        done
        
        gh release create "$new_version" $assets --generate-notes
        log_info "✓ GitHub release created: $new_version"
    else
        log_warn "GitHub CLI not available, skipping release creation"
    fi
    
    log_info "Release complete: $new_version"
}

cmd_clean() {
    log_info "Cleaning build artifacts..."
    rm -rf build/
    log_info "✓ Clean complete"
}

# Main Command Router
main() {
    # Load configuration and plugins
    load_config
    load_plugins
    
    # Register core services (can be overridden by plugins)
    register_service "logger" "log_info"
    register_service "config" "load_config"
    
    # Route commands
    case "${1:-help}" in
        init)
            shift
            cmd_init "$@"
            ;;
        doctor)
            cmd_doctor
            ;;
        devices)
            cmd_devices
            ;;
        build)
            shift
            cmd_build "$@"
            ;;
        run)
            shift
            cmd_run "$@"
            ;;
        watch)
            shift
            cmd_watch "$@"
            ;;
        test)
            cmd_test
            ;;
        release)
            shift
            cmd_release "$@"
            ;;
        clean)
            cmd_clean
            ;;
        help|--help|-h)
            show_help
            ;;
        --version|-v)
            echo "ciqx $CIQX_VERSION"
            ;;
        *)
            log_error "Unknown command: $1"
            show_help
            exit 1
            ;;
    esac
}

# Run main if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi